
<!DOCTYPE HTML>

<html lang="en">
    <div class = "title">
        <h1> Vegetarian & Vegan Dining in the U.S. </h1>
        <h3>INFO 5100 Final Project</h3>
    </div>
<head>
    <title>Project 3</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
    
    h1{
          padding-top: 100;
          padding-bottom:100;
          font-size: 50;
          text-align: center;
          font-family: 'Arial';
          color:white;
          font-weight: bolder;
          background-color: navy;
      }
    .title {
            text-align: center;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 50;
        }

    .box_1 {
        display: flex;
        width:1440px;
        margin-left: auto; 
        margin-right: auto;
    }

    .map_positioning{
        flex: 1;
        width:900px;
        height: 600px;
        margin-left:0px;
        padding:10px;
        outline: solid 1px black;
        background-color:white;
    }

    .filters{
        width: 500px;
        height: 600px;
        /* top: 50px; */
        margin-left:1px;
        margin-right: 20px;
        padding: 10px;
        outline: solid 1px black;
        background-color: white;
    }

    .cuisines_filter{
        height: 70px;
        padding-left:20px;
        text-align:left;
        background-color: white;
        margin-top: -20px;
    }
    .dietary_filter{
        height: 70px;
        padding-left:20px;
        text-align:left;
        background-color: white;
        margin-top: -20px;
    }
    .dietary_filter span{
        margin-right:10px;
        padding: 8px;
        border: solid black 2px;
        border-radius: 5px;
        background-color: white;
    }
    .cuisines_filter span{
        margin-right:10px;
        margin-bottom:5px;
        margin-left:3px;
        float:left;
        padding: 8px;
        border: solid black 1px;
        border-radius: 5px;
        background-color: white;
    }

    .box_2 {
        display: flex;
        width:1440px;
        margin-left: auto; 
        margin-right: auto;
    }

    .barchart-container {
        width:720px;
        height: 500px;
        padding-left:10px;
        padding-right:10px;
        margin-left:0px;
        outline: solid 1px black;
        background-color:white;
    }

    .rectangle{
        width: 720px;
        height: 500px;
        margin-left:1px;
        margin-right: 20px;
        padding-left: 10px;
        padding-right:10px;
        outline: solid 1px black;
        background-color: white;
    }

        </style>
        </head>

        <div class = "box_1">
            <div class="map_positioning">
                <svg id="us_map" height="600" width="900"></svg>
            </div>

            <div class = "filters">
                <h3>FILTERS</h3>
                <div class = "dietary_filter">
                    <h4>Dietary</h4>
                </div>
                <div class = "cruisine_filter">
                    <h4>Cuisine:</h4> 
                </div>
            </div>
        </div>

        <div class = box_2>
            <div class="barchart-container">
                <h4> Distribution of Restaurants by Cuisine </h4>
                <svg id="barchart" height="450" width="720" ></svg>            
            </div>

            <div class = "rectangle">
                <h4> whatever other chart we decide to add </h4>
            </div>
        </div>

<script>
 // FILTERING 
    const dietary_ids = ["Vegan","Vegetarian", "Both", "All Dietary"];
    const cuisines_ids = ["American","General Mediterranean", "Italian", 
    "Japanese","Kosher","Mexican","Middle Eastern","Thai","Chinese", "All Cuisines"];

// // CHANGE FITER COLOR
function changeColor(name, array_name){
        var element = document.getElementById(name);
        element.style.backgroundColor = "skyblue";
        //find what array to sort through
        if (array_name === 'dietary_ids'){
            list_ids = dietary_ids;
        }//else for other array names
        else if (array_name === 'cuisines_ids'){
            list_ids = cuisines_ids;
        }//else for other array names
        for (var i=0; i<list_ids.length;i++){
            var value = list_ids[i];
            if (value != name){
                element = document.getElementById(value);
                if (element.style.backgroundColor === "skyblue"){
                    element.style.backgroundColor = "white";
                }
            }
        }
    }

const requestData = async () => {
//LOAD Vegetarian/Vegan DATASET
  var data = await d3.csv("./cleaned_restaurants_data.csv");
       console.log(data)
 //LOAD MAP DATASET   
    const us = await d3.json("./counties-10m.json");

  
    //LOAD Population DATASET
    let pop = await d3.csv('USpopulation2019.csv', d3.autoType);
    console.log(pop, "population csv")
    popByState = [];
    pop.forEach(d => {
        popByState[d.NAME] = d.population_estimate2019;
    });
    let popVals = d3.map(pop, d => d.population_estimate2019);
    console.log(popVals);
    console.log(popByState);

    const states = topojson.feature(us, us.objects.states);                 

    const statesMesh = topojson.mesh(us, us.objects.states);
    const counties = topojson.feature(us, us.objects.counties);
    const countiesMesh = topojson.mesh(us, us.objects.counties);

    let map = d3.select("#us_map");
    let mapWidth = map.attr("width");
    let mapHeight = map.attr("height");
    var projection = d3.geoAlbersUsa().scale(800).translate([487.5, 305]);
    let path = d3.geoPath().projection(projection);
    let viewport = map.append("g");

    //Add pop data to each of the states
    states.features.forEach(d => {
                    state = d.properties.name;
                    if(state in popByState) {
                        //add to the topojson
                        d.properties.population = popByState[state];
                    }
                    else {
                        d.properties.population = null;
                    }
                });
console.log(states);
                const colorScaleRange = ["#eaeff9", "#bec9e0", "#99abd1", "#6e86b8", "#4e6aa3", "#2e4a85", "#142854"];
                let popScale = d3.scaleQuantile().domain(popVals).range(colorScaleRange);
                console.log("popScale",popScale)
                console.log(counties, "counties")

   //ADDING PATHS FOR ZOOM FEATURE
    viewport.append("path")
        .attr("class","graticule")
        .attr("fill","none")
        .attr("d",path(d3.geoGraticule10()));
    viewport.selectAll(".state").data(states.features)
        .enter()
        .append("path")
        .attr("class","state")
        .attr("fill", d => { if (d.properties.population===null) {
                                            return  "#808080"; }
                                         else {
                                           return popScale(d.properties.population);}})
        .attr("d", path);
    viewport.selectAll(".county").data(counties.features)
        .enter()
        .append("path")
        .attr("class","county")
        .attr("fill","lightgrey")
        .attr("visibility", "hidden")
        .attr("d", path);
    viewport.append("path")
      .datum(countiesMesh)
      .attr("class","county-outline")
      .attr("visibility", "hidden")
      .attr("fill","lightgrey")
      .style("stroke-width", 3)
      .style("stroke", "white")
      .attr("d", path);
    viewport.append("path")
      .datum(statesMesh)
      .attr("class","state-outline")
      .style("stroke-width", 3)
      .attr("fill","none")
     .style("stroke", "black")
      .attr("d", path);


    // pannign AND ZOOM HERE
    
    var zoom = d3.zoom()
                  .scaleExtent([1,10])
                  //.translateExtent([[-50,-50],[mapWidth+50,mapHeight+50]])  // to lock to edges
    
                  .on("zoom", mapZoomed);

    map.call(zoom);

    map.call(zoom.transform, d3.zoomIdentity); // Executes zoomed() once because we technically have changed the transform

    function mapZoomed({transform}) {

      // Transform the group object to reflect the zoom action
      viewport.attr("transform", transform.toString() );

      // Divide by scale to make sure strokes remain a consistent width during zooming
      viewport.select(".state-outline")
                  .style("stroke-width", 3 / transform.k);
      viewport.select(".county-outline")
                  .style("stroke-width", 2 / transform.k);

      // Expose county layer when sufficiently zoomed
      viewport.select(".county-outline")
                .attr("visibility", (transform.k > 2) ? "visible" : "hidden");
      viewport.selectAll(".county")
                .attr("visibility", (transform.k > 2) ? "visible" : "hidden");
        
    }

    viewport.selectAll(".state").on("click",clicked);
    viewport.selectAll(".county").on("click",clicked);


    function clicked(event, d) {
      console.log(d)

      let bounds = path.bounds(d.geometry); // get bounds for clicked state/county
      let dx = bounds[1][0] - bounds[0][0]; // width of state/county
      let dy = bounds[1][1] - bounds[0][1]; // height of state/county
      let x = (bounds[0][0] + bounds[1][0]) / 2; // center x of state/county
      let y = (bounds[0][1] + bounds[1][1]) / 2; // center y of state/county


      let scale = Math.max(10, Math.min(10, 1.2 / Math.max( dx / mapWidth, 
                                                           dy / mapHeight )));

      let translate = [mapWidth / 2 - x * scale, mapHeight / 2 - y * scale];


      let newTransform = d3.zoomIdentity
                            .translate(translate[0],translate[1])
                            .scale(scale);

      map.transition().duration(1000).call(zoom.transform, newTransform);

    }
    data.forEach( d => {
            d.latitude = Number(d.latitude);
            d.longitude = Number(d.longitude);
            d.position = projection( [d.longitude, d.latitude] );

        });
        console.log(data);

    let circles = map.selectAll("circle.dot").data(data)
                                .join("circle")
                                .attr("class","dot")
                                .attr("r", 5)
                                .attr("fill", "red")
                                .attr("opacity", 0.6)
                                .attr("cx", d => d.position[0])
                                .attr("cy", d => d.position[1])


var current_filters = {"dietary":"All Dietary","cuisines":"All Cuisines" };
console.log(current_filters);
//DIETARY FILTER
dietary_ids.forEach(function(d,i){
    d3.select('.dietary_filter')
        .append("span")
        .attr('id',d)
        .text(d)
        .on('click', function(){
            changeColor(d,"dietary_ids");
            if (d === 'All Dietary'){
                current_filters['dietary']="All Dietary";
            }
            else{
                current_filters['dietary']=d;
            }
            updateMap();
            // callgraphs('year', d);
        })
})
//CUISINE FILTER
cuisines_ids .forEach(function(d,i){
    d3.select('.cuisines_filter')
        .append("span")
        .attr('id',d)
        .text(d)
        .on('click', function(){
            changeColor(d,"cuisines_ids");
            if (d === 'All Cuisines'){
                current_filters['cuisines']="All Cuisines";
            }
            else{
                current_filters['cuisines']=d;
            }
            updateMap();
    
        })
})

function updateMap(){
            circles.attr('visibility', circleD => {
                if ((circleD['dietary'].toString() !=current_filters['dietary']) && current_filters['dietary']!="All Dietary"){
                    return 'hidden';
                }
                else if ((circleD['cuisines'].toString() !=current_filters['cuisines']) && current_filters['cuisines']!="All Cuisines"){
                    return 'hidden';
                }
                else{
                    return "";
                }

         })
        };

        // //Cuisine Distribution Bar Chart 

        // const svg = d3.select("svg#barchart");
        // const width = svg.attr("width");
        // const height = svg.attr("height");
        // const margin = {top: 10, right: 10, bottom: 50, left: 50};
        // const chartWidth = width - margin.left - margin.right;
        // const chartHeight = height - margin.top - margin.bottom;

        // let annotations = svg.append("g").attr("id","annotations");
        // let chartArea = svg.append("g").attr("id","points")
        //                 .attr("transform",`translate(${margin.left},${margin.top})`);

        // const cuisine_ct = await d3.csv("./cuisine_count.csv");

        // cuisine_ct.forEach ( d => {
        //     d["cuisines"] = Number(d["cuisines"])          
        // })
        // console.log(cuisine_ct)

        // var topCuisines = cuisine_ct.sort(function(a, b) {
        //     return d3.descending(+a.Impressions, +b.Impressions);
        // }).slice(0, 10);
        // console.log(topCuisines)

        // const countScale = d3.scaleLinear().domain([0,40]).range([chartHeight, 0]);
        // let leftAxis = d3.axisLeft(countScale).tickFormat(d3.format('0'));
        // let leftGridlines = d3.axisLeft(countScale)
        //                         .tickSize(-chartWidth-10)
        //                         .tickFormat("")
        // annotations.append("g")
        //             .attr("class", "y axis")
        //             .attr("transform",`translate(${margin.left-10},${margin.top})`)
        //             .call(leftAxis)
        // annotations.append("g")
        //             .attr("class", "y gridlines")
        //             .attr("transform",`translate(${margin.left-10},${margin.top})`)
        //             .call(leftGridlines);

        // let bottomAxis = d3.axisBottom()
        // let bottomAxisG = annotations.append("g")
        //                             .attr("class", "x axis")
        //                             .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
        
        // const cuisine_types = ["American", "Chinese", "Mediterranean", "Italian", "Japanese", "Kosher", "Mexican", 
        //                         "Middle Eastern", "Thai", "Other"] 
        // const cuisineScale = d3.scaleBand().domain(cuisine_types).range([0, chartWidth])
        //                                 .padding(0.05);
        
        // bottomAxis.scale(cuisineScale)
        // bottomAxisG.transition().call(bottomAxis);

        // chartArea.selectAll('rect.bar').data( cuisine_ct, d => d.cuisines )
        //      .join( enter => enter.append('rect')
        //                           .attr('class','bar')
        //                           .attr("fill", "steelblue")
        //                           .attr("x", cuisineScale)
        //                           .attr("y", d => countScale(d.cuisines))
        //                           .attr("height", d => countScale(0) - countScale(d.cuisines))
        //                           .attr("width", cuisineScale.bandwidth())
        //                           .attr("opacity", 0)) // Set opacity low, then animate to 1 to make them fade in


  }

  requestData();
  
  
</script>
        </html>